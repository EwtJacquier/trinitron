<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CRT Webcam Viewer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      color: white;
      font-family: sans-serif;
      height: 100%;
      overflow: hidden;
    }

    #menu {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      z-index: 10;
    }

    select, button {
      margin: 5px 0;
      padding: 5px;
      width: 100%;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    #crt-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;

      background:
        repeating-linear-gradient(
          to bottom,
          rgba(0, 0, 0, 0.15),
          rgba(0, 0, 0, 0.15) 1px,
          transparent 1px,
          transparent 3px
        );

      mix-blend-mode: multiply;
      z-index: 2;
      animation: flicker 0.15s infinite alternate;
    }

    @keyframes flicker {
      0%   { opacity: 0.93; }
      100% { opacity: 1; }
    }

    #fps {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 14px;
      background: rgba(0,0,0,0.5);
      padding: 5px;
    }
  </style>
</head>
<body>

  <div id="menu">
    <label>Camera:
      <select id="cameraSelect"></select>
    </label><br>
    <label>Microphone:
      <select id="micSelect"></select>
    </label><br>
    <button id="startBtn">Start</button>
  </div>

  <video id="video" autoplay playsinline muted style="display:none;"></video>
  <audio id="audio" autoplay controls style="display:none;"></audio>
  <div id="container">
    <canvas id="canvas"></canvas>
    <div id="crt-overlay"></div>
  </div>
  <div id="fps">FPS: 0</div>

  <script>
    const cameraSelect = document.getElementById('cameraSelect');
    const micSelect = document.getElementById('micSelect');
    const startBtn = document.getElementById('startBtn');
    const menu = document.getElementById('menu');
    const video = document.getElementById('video');
    const audio = document.getElementById('audio');
    const canvas = document.getElementById('canvas');
    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = internalWidth;
    offscreenCanvas.height = internalHeight;
    const offscreenCtx = offscreenCanvas.getContext('2d');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const fpsDisplay = document.getElementById('fps');

    let videoStream;
    let audioStream;
    let lastTime = performance.now();
    let frames = 0;

    const internalWidth = 256;
    const internalHeight = 224;

    async function requestPermissionsAndListDevices() {
      try {
        const tempStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        await listDevices();
        tempStream.getTracks().forEach(t => t.stop());
      } catch (err) {
        alert("Permission denied or error accessing media: " + err.message);
        console.error(err);
      }
    }

    async function listDevices() {
      const devices = await navigator.mediaDevices.enumerateDevices();

      cameraSelect.innerHTML = '';
      micSelect.innerHTML = '';

      devices.forEach(device => {
        const option = document.createElement('option');
        option.value = device.deviceId;
        option.text = device.label || `${device.kind}`;

        if (device.kind === 'videoinput') {
          cameraSelect.appendChild(option);
        } else if (device.kind === 'audioinput') {
          micSelect.appendChild(option);
        }
      });
    }

    async function startStream() {
      const videoSource = cameraSelect.value;
      const audioSource = micSelect.value;

      const videoConstraints = {
        deviceId: videoSource ? { exact: videoSource } : undefined,
        frameRate: { ideal: 60, max: 60 },
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      };

      const audioConstraints = {
        deviceId: audioSource ? { exact: audioSource } : undefined,
        autoGainControl: false,
        echoCancellation: false,
        googAutoGainControl: false,
        noiseSuppression: false
      };

      try {
        if (videoStream) videoStream.getTracks().forEach(t => t.stop());
        if (audioStream) audioStream.getTracks().forEach(t => t.stop());

        videoStream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints });
        audioStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });

        video.srcObject = videoStream;
        audio.srcObject = audioStream;

        video.onloadedmetadata = () => {
          video.play();
          menu.style.display = 'none';
          startCRT();
        };
      } catch (err) {
        alert("Error starting media: " + err.message);
        console.error(err);
      }
    }

    function applyCRTEffect(videoElement, ctx, x, y, width, height) {
      const imageData = ctx.getImageData(x, y, width, height);
      const data = imageData.data;

      // Criar um buffer para guardar os canais originais
      const original = new Uint8ClampedArray(data);

      for (let row = 0; row < height; row++) {
        for (let col = 0; col < width; col++) {
          const i = (row * width + col) * 4;

          // RGB originais do pixel atual
          const r = original[i];
          const g = original[i + 1];
          const b = original[i + 2];
          const a = original[i + 3];

          // Canal verde fica no pixel atual
          data[i + 1] = g;

          // Canal vermelho desloca para pixel à esquerda (se existir)
          if (col > 0) {
            const leftI = (row * width + (col - 1)) * 4;
            data[leftI] = r;
          } else {
            // No primeiro pixel, manter vermelho original
            data[i] = r;
          }

          // Canal azul desloca para pixel à direita (se existir)
          if (col < width - 1) {
            const rightI = (row * width + (col + 1)) * 4;
            data[rightI + 2] = b;
          } else {
            // No último pixel, manter azul original
            data[i + 2] = b;
          }

          // Alpha permanece o mesmo no pixel atual
          data[i + 3] = a;
        }
      }

      // Opcional: scanlines (linhas escuras)
      for (let row = 0; row < height; row++) {
        if (row % 2 === 0) {
          for (let col = 0; col < width; col++) {
            const i = (row * width + col) * 4;
            data[i]     = data[i] * 0.7;
            data[i + 1] = data[i + 1] * 0.7;
            data[i + 2] = data[i + 2] * 0.7;
          }
        }
      }

      ctx.putImageData(imageData, x, y);
    }

    /*
    function applyCRTEffect(videoElement, ctx, x, y, width, height) {
      const imageData = ctx.getImageData(x, y, width, height);
      const data = imageData.data;

      for (let row = 0; row < height; row++) {
        const isScanline = row % 2 === 0;

        for (let col = 0; col < width; col++) {
          const i = (row * width + col) * 4;

          // Simula subpixels RGB deslocando ligeiramente
          let r = data[i];
          let g = data[i + 1];
          let b = data[i + 2];

          // Pixel blend horizontal simples
          if (col < width - 1) {
            const ni = ((row * width) + (col + 1)) * 4;
            r = (r + data[ni]) / 2;
            g = (g + data[ni + 1]) / 2;
            b = (b + data[ni + 2]) / 2;
          }

          // Subpixel shift: leve aberração cromática
          data[i]     = r * 1.1; // R: um pouco mais forte
          data[i + 1] = g * 1.05; // G: suave
          data[i + 2] = b * 0.95; // B: escurecido para "profundidade"

          // Scanline darkening
          if (isScanline) {
            data[i]     *= 0.7;
            data[i + 1] *= 0.7;
            data[i + 2] *= 0.7;
          }

          // Brilho leve
          const brightness = 1.03;
          data[i]     = Math.min(255, data[i] * brightness);
          data[i + 1] = Math.min(255, data[i + 1] * brightness);
          data[i + 2] = Math.min(255, data[i + 2] * brightness);
        }
      }

      ctx.putImageData(imageData, x, y);

      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
      for (let scanY = y; scanY < y + height; scanY += 2) {
        ctx.fillRect(x, scanY, width, 1);
      }
    }
      */

    function startCRT() {
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      function drawFrame() {
        // Desenha o vídeo no canvas interno
        offscreenCtx.drawImage(video, 0, 0, internalWidth, internalHeight);

        // Aplica o efeito CRT no canvas interno
        applyCRTEffect(video, offscreenCtx, 0, 0, internalWidth, internalHeight);

        // Limpa o canvas principal
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const videoAspect = internalWidth / internalHeight;
        const canvasAspect = canvas.width / canvas.height;

        let drawWidth, drawHeight, offsetX, offsetY;

        if (canvasAspect > videoAspect) {
          // canvas mais largo que o vídeo
          drawHeight = canvas.height;
          drawWidth = drawHeight * videoAspect;
          offsetX = (canvas.width - drawWidth) / 2;
          offsetY = 0;
        } else {
          // canvas mais alto que o vídeo
          drawWidth = canvas.width;
          drawHeight = drawWidth / videoAspect;
          offsetX = 0;
          offsetY = (canvas.height - drawHeight) / 2;
        }

        // Desenha o canvas interno já com efeito no canvas principal, escalando
        ctx.imageSmoothingEnabled = false; // importante pra manter pixel art nítida
        ctx.drawImage(offscreenCanvas, 0, 0, internalWidth, internalHeight, offsetX, offsetY, drawWidth, drawHeight);


        applyCRTEffect(video, ctx, offsetX, offsetY, drawWidth, drawHeight);
        
        frames++;
        const now = performance.now();
        if (now - lastTime >= 1000) {
          fpsDisplay.textContent = `FPS: ${frames}`;
          frames = 0;
          lastTime = now;
        }

        requestAnimationFrame(drawFrame);
      }

      requestAnimationFrame(drawFrame);
    }

    startBtn.addEventListener('click', startStream);
    requestPermissionsAndListDevices();
  </script>
</body>
</html>
