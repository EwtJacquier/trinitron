<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CRT Webcam Viewer WebGL</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: black; color: white;
      height: 100%;
      overflow: hidden;
      font-family: sans-serif;
    }
    #menu {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 8px;
      z-index: 10;
    }
    select, button {
      margin: 5px 0;
      padding: 5px;
      width: 100%;
    }
    #container {
      position: relative;
      width: 100vw; height: 100vh;
      overflow: hidden;
    }
    #crt-overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(0, 0, 0, 0.15),
          rgba(0, 0, 0, 0.15) 1px,
          transparent 1px,
          transparent 3px
        );
      mix-blend-mode: multiply;
      z-index: 2;
      animation: flicker 0.15s infinite alternate;
    }
    @keyframes flicker {
      0%   { opacity: 0.93; }
      100% { opacity: 1; }
    }
    #fps {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 14px;
      background: rgba(0,0,0,0.5);
      padding: 5px;
      z-index: 10;
    }
  </style>
</head>
<body>

<div id="menu">
  <label>Camera:
    <select id="cameraSelect"></select>
  </label><br>
  <label>Microphone:
    <select id="micSelect"></select>
  </label><br>
  <button id="startBtn">Start</button>
</div>

<video id="video" autoplay playsinline muted style="display:none;"></video>
<audio id="audio" autoplay controls style="display:none;"></audio>
<div id="container">
  <canvas id="canvas"></canvas>
  <div id="crt-overlay"></div>
</div>
<div id="fps">FPS: 0</div>

<script>
  const cameraSelect = document.getElementById('cameraSelect');
  const micSelect = document.getElementById('micSelect');
  const startBtn = document.getElementById('startBtn');
  const menu = document.getElementById('menu');
  const video = document.getElementById('video');
  const audio = document.getElementById('audio');
  const canvas = document.getElementById('canvas');
  const fpsDisplay = document.getElementById('fps');

  let videoStream;
  let audioStream;
  let gl;
  let program;
  let positionBuffer;
  let texCoordBuffer;
  let texture;
  let lastTime = performance.now();
  let frames = 0;

  // Aspect ratio vars
  let canvasWidth, canvasHeight;
  let videoAspect;

  // Vertex shader source
  const vsSource = `
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    varying vec2 v_texCoord;

    void main() {
      gl_Position = vec4(a_position, 0, 1);
      v_texCoord = a_texCoord;
    }
  `;

  // Fragment shader source
  const fsSource = `
    precision mediump float;
    varying vec2 v_texCoord;
    uniform sampler2D u_texture;

    void main() {
      vec4 color = texture2D(u_texture, v_texCoord);
      // Optional: add CRT effect here if quiser depois
      gl_FragColor = color;
    }
  `;

  // Helper to compile shader
  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error('Shader compile failed:', gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  // Helper to create program
  function createProgram(gl, vsSource, fsSource) {
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Program link failed:', gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return null;
    }
    return program;
  }

  async function requestPermissionsAndListDevices() {
    try {
      const tempStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      await listDevices();
      tempStream.getTracks().forEach(t => t.stop());
    } catch (err) {
      alert("Permission denied or error accessing media: " + err.message);
      console.error(err);
    }
  }

  async function listDevices() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    cameraSelect.innerHTML = '';
    micSelect.innerHTML = '';

    devices.forEach(device => {
      const option = document.createElement('option');
      option.value = device.deviceId;
      option.text = device.label || `${device.kind}`;
      if (device.kind === 'videoinput') {
        cameraSelect.appendChild(option);
      } else if (device.kind === 'audioinput') {
        micSelect.appendChild(option);
      }
    });
  }

  async function startStream() {
    const videoSource = cameraSelect.value;
    const audioSource = micSelect.value;

    const videoConstraints = {
      deviceId: videoSource ? { exact: videoSource } : undefined,
      frameRate: { ideal: 60, max: 60 },
      width: { ideal: 1920 },
      height: { ideal: 1080 }
    };

    const audioConstraints = {
      deviceId: audioSource ? { exact: audioSource } : undefined,
      autoGainControl: false,
      echoCancellation: false,
      googAutoGainControl: false,
      noiseSuppression: false
    };

    try {
      if (videoStream) videoStream.getTracks().forEach(t => t.stop());
      if (audioStream) audioStream.getTracks().forEach(t => t.stop());

      videoStream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints });
      audioStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });

      video.srcObject = videoStream;
      audio.srcObject = audioStream;

      video.onloadedmetadata = () => {
        video.play();
        menu.style.display = 'none';
        initWebGL();
        startRenderLoop();
      };
    } catch (err) {
      alert("Error starting media: " + err.message);
      console.error(err);
    }
  }

  function initWebGL() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    gl = canvas.getContext('webgl');
    if (!gl) {
      alert('WebGL not supported');
      return;
    }

    program = createProgram(gl, vsSource, fsSource);
    gl.useProgram(program);

    // Look up attribute locations
    const positionLocation = gl.getAttribLocation(program, "a_position");
    const texCoordLocation = gl.getAttribLocation(program, "a_texCoord");

    // Create buffer for positions
    positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    // We will update positions later to respect aspect ratio, but start with full quad:
    // clipspace coords from -1 to 1 in X and Y
    setPositionFullScreen();

    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    // Create buffer for texture coords
    texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    // texture coords go from (0,0) top-left to (1,1) bottom-right
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      0, 0,
      1, 0,
      0, 1,
      0, 1,
      1, 0,
      1, 1,
    ]), gl.STATIC_DRAW);

    gl.enableVertexAttribArray(texCoordLocation);
    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

    // Create texture
    texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);

    // Set params so we can render any size video
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

    videoAspect = video.videoWidth / video.videoHeight;

    // Resize canvas on window resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      updatePositionsForAspectRatio();
    });

    updatePositionsForAspectRatio();
  }

  function setPositionFullScreen() {
    // Full screen quad coords for clipspace -1..1 X and Y
    const fullScreenCoords = new Float32Array([
      -1,  1,
       1,  1,
      -1, -1,
      -1, -1,
       1,  1,
       1, -1,
    ]);
    gl.bufferData(gl.ARRAY_BUFFER, fullScreenCoords, gl.STATIC_DRAW);
  }

  function updatePositionsForAspectRatio() {
    if (!gl) return;

    const canvasRatio = canvas.width / canvas.height;

    let drawWidth, drawHeight;

    if (canvasRatio > videoAspect) {
      // Canvas mais largo que video: limitar pela altura
      drawHeight = 2; // clipspace coords vão de -1 a 1 => 2 unidades
      drawWidth = 2 * videoAspect / canvasRatio;
    } else {
      // Canvas mais alto que video: limitar pela largura
      drawWidth = 2;
      drawHeight = 2 * canvasRatio / videoAspect;
    }

    const x1 = -drawWidth / 2;
    const x2 = drawWidth / 2;
    const y1 = drawHeight / 2;
    const y2 = -drawHeight / 2;

    const positions = new Float32Array([
      x1, y1,
      x2, y1,
      x1, y2,
      x1, y2,
      x2, y1,
      x2, y2,
    ]);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
  }

  /*
  let lastDrawTime = 0;
  const targetFPS = 60;
  const frameDuration = 1000 / targetFPS;
  */

  function startRenderLoop() {
    function render() {
      if (video.readyState >= 2) { // HAVE_CURRENT_DATA
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Atualiza textura com frame do vídeo
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          video
        );

        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        frames++;
        if (now - lastTime >= 1000) {
          fpsDisplay.textContent = `FPS: ${frames}`;
          frames = 0;
          lastTime = now;
        }
      }

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  }

  startBtn.onclick = () => {
    startStream();
  };

  requestPermissionsAndListDevices();
</script>

</body>
</html>
